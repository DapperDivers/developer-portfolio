# Test Automation Guidelines

This document outlines the guidelines and best practices for test automation in the Developer Portfolio project. It covers the setup, configuration, and execution of automated tests as part of the development workflow and CI/CD pipeline.

## Automated Testing Setup

### Test Runners and Frameworks

The project uses the following test runners and frameworks:

- **Jest**: Primary test runner for unit and integration tests
- **React Testing Library**: Testing utilities for React components
- **Playwright**: End-to-end testing framework
- **Storybook**: Component development and visual testing

### Directory Structure

```
project-root/
├── src/
│   ├── components/
│   │   └── [ComponentName]/
│   │       ├── [ComponentName].jsx
│   │       ├── [ComponentName].test.jsx
│   │       └── [ComponentName].enhanced.test.jsx
│   ├── hooks/
│   │   ├── useCustomHook.js
│   │   └── __tests__/
│   │       └── useCustomHook.test.js
│   └── __tests__/
│       └── integration/
│           └── featureIntegration.test.jsx
├── e2e/
│   ├── setup.ts
│   └── feature.spec.js
└── config/
    └── test/
        ├── base.config.ts
        ├── unit.config.ts
        ├── e2e.config.ts
        └── storybook.config.ts
```

## Test Configuration

### Jest Configuration

Jest is configured in `vitest.config.ts` for unit and integration tests:

```js
// vitest.config.ts
export default defineConfig({
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      reporter: ['text', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.test.{js,jsx,ts,tsx}',
        '**/__tests__/**'
      ]
    },
    include: ['src/**/*.test.{js,jsx,ts,tsx}'],
    exclude: ['e2e/**', 'node_modules/**'],
    testTimeout: 10000
  }
});
```

### Playwright Configuration

Playwright is configured in `playwright.config.js` for end-to-end tests:

```js
// playwright.config.js
module.exports = {
  testDir: './e2e',
  timeout: 30000,
  retries: process.env.CI ? 2 : 0,
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { browserName: 'chromium' }
    },
    {
      name: 'firefox',
      use: { browserName: 'firefox' }
    },
    {
      name: 'webkit',
      use: { browserName: 'webkit' }
    }
  ]
};
```

### Storybook Configuration

Storybook is configured for component development and visual testing:

```js
// .storybook/main.ts
module.exports = {
  stories: ['../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/addon-interactions',
    '@storybook/addon-a11y'
  ],
  framework: {
    name: '@storybook/react-vite',
    options: {}
  }
};
```

## Running Tests Locally

### Unit and Integration Tests

Run unit and integration tests using the following npm scripts:

```bash
# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage

# Run specific tests
npm test -- Button
```

### End-to-End Tests

Run end-to-end tests using the following npm scripts:

```bash
# Start the development server
npm run dev

# In another terminal, run all E2E tests
npm run test:e2e

# Run specific E2E tests
npm run test:e2e -- projects.spec.js

# Run E2E tests in headed mode
npm run test:e2e:headed
```

### Visual Tests

Run visual tests using Storybook:

```bash
# Start Storybook
npm run storybook

# Run visual tests
npm run test:visual
```

## Continuous Integration

### CI/CD Pipeline

The project uses GitHub Actions for CI/CD. The pipeline includes the following steps:

1. **Checkout**: Clone the repository
2. **Setup**: Install dependencies
3. **Lint**: Run ESLint
4. **Unit Tests**: Run unit and integration tests
5. **Build**: Build the application
6. **E2E Tests**: Run end-to-end tests
7. **Visual Tests**: Run visual regression tests
8. **Deploy**: Deploy to staging/production (on specific branches)

### GitHub Actions Workflow

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
          cache: 'npm'
      - run: npm ci
      - run: npm run lint
      - run: npm test
      - run: npm run build
      - run: npm run test:e2e
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: test-results
          path: |
            coverage/
            playwright-report/
```

### Test Reports

Test reports are generated and uploaded as artifacts in the CI pipeline:

- **Coverage Reports**: Generated by Jest
- **E2E Test Reports**: Generated by Playwright
- **Visual Test Reports**: Generated by Storybook/Chromatic

## Test Automation Best Practices

### 1. Keep Tests Fast

- Optimize test execution time
- Use appropriate mocking strategies
- Run tests in parallel when possible

### 2. Ensure Test Stability

- Avoid flaky tests
- Use stable selectors
- Implement proper waiting mechanisms
- Handle asynchronous operations correctly

```jsx
// Good: Proper async handling
test('loads data from API', async () => {
  render(<DataComponent />);
  
  // Wait for loading to complete
  await waitForElementToBeRemoved(() => screen.getByText('Loading...'));
  
  // Assert on loaded data
  expect(screen.getByText('Data Item 1')).toBeInTheDocument();
});

// Bad: No proper waiting
test('loads data from API', () => {
  render(<DataComponent />);
  
  // This might fail if the data hasn't loaded yet
  expect(screen.getByText('Data Item 1')).toBeInTheDocument();
});
```

### 3. Implement Proper Test Isolation

- Reset state between tests
- Clean up after tests
- Use beforeEach/afterEach hooks for setup and teardown

```jsx
describe('UserProfile component', () => {
  // Setup before each test
  beforeEach(() => {
    localStorage.clear();
    jest.clearAllMocks();
  });
  
  // Cleanup after each test
  afterEach(() => {
    cleanup();
  });
  
  test('displays user information', () => {
    // Test implementation
  });
});
```

### 4. Use Appropriate Assertions

- Use specific assertions
- Avoid overly generic assertions
- Use custom matchers when needed

```jsx
// Good: Specific assertions
expect(screen.getByRole('button')).toBeDisabled();
expect(screen.getByText('Success')).toHaveClass('text-green');

// Bad: Generic assertions
expect(screen.getByRole('button').disabled).toBe(true);
expect(screen.getByText('Success').className).toContain('text-green');
```

### 5. Implement Retry Mechanisms

- Implement retry mechanisms for flaky tests
- Use conditional retries based on failure type

```js
// playwright.config.js
module.exports = {
  retries: process.env.CI ? 2 : 0,
  // ...
};
```

### 6. Parallelize Test Execution

- Run tests in parallel to reduce execution time
- Ensure tests are independent for parallel execution

```js
// vitest.config.ts
export default defineConfig({
  test: {
    // ...
    pool: 'forks', // Run tests in parallel
    poolOptions: {
      threads: {
        singleThread: false,
      },
    },
  }
});
```

### 7. Implement Test Data Management

- Use fixtures for test data
- Implement data generation utilities
- Avoid hardcoded test data

```jsx
// Test data fixture
const userFixture = {
  id: '123',
  name: 'Test User',
  email: 'test@example.com',
  role: 'user'
};

// Data generation utility
const generateUser = (overrides = {}) => ({
  id: `user-${Math.random().toString(36).substr(2, 9)}`,
  name: 'Test User',
  email: 'test@example.com',
  role: 'user',
  ...overrides
});

// Using the fixture
test('displays user profile', () => {
  render(<UserProfile user={userFixture} />);
  expect(screen.getByText(userFixture.name)).toBeInTheDocument();
});

// Using the generator
test('displays custom user profile', () => {
  const customUser = generateUser({ name: 'Custom Name', role: 'admin' });
  render(<UserProfile user={customUser} />);
  expect(screen.getByText(customUser.name)).toBeInTheDocument();
  expect(screen.getByText('Admin')).toBeInTheDocument();
});
```

## Test Automation for Specific Features

### 1. Form Testing

- Test form validation
- Test form submission
- Test error handling

```jsx
test('validates form fields', async () => {
  render(<ContactForm />);
  
  // Submit without filling required fields
  fireEvent.click(screen.getByText('Submit'));
  
  // Check for validation errors
  expect(screen.getByText('Name is required')).toBeInTheDocument();
  expect(screen.getByText('Email is required')).toBeInTheDocument();
  
  // Fill fields and submit
  fireEvent.change(screen.getByLabelText('Name'), {
    target: { value: 'Test User' }
  });
  fireEvent.change(screen.getByLabelText('Email'), {
    target: { value: 'test@example.com' }
  });
  fireEvent.click(screen.getByText('Submit'));
  
  // Check for success message
  expect(await screen.findByText('Form submitted successfully')).toBeInTheDocument();
});
```

### 2. API Integration Testing

- Mock API responses
- Test loading states
- Test error handling

```jsx
test('handles API errors', async () => {
  // Mock API error
  server.use(
    rest.get('/api/users', (req, res, ctx) => {
      return res(ctx.status(500), ctx.json({ error: 'Server error' }));
    })
  );
  
  render(<UserList />);
  
  // Check for loading state
  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  // Check for error message
  expect(await screen.findByText('Failed to load users')).toBeInTheDocument();
});
```

### 3. Authentication Testing

- Test login/logout flows
- Test protected routes
- Test authentication state

```jsx
test('redirects to login page for protected routes', async () => {
  // Mock unauthenticated state
  jest.spyOn(AuthService, 'isAuthenticated').mockReturnValue(false);
  
  render(
    <MemoryRouter initialEntries={['/dashboard']}>
      <App />
    </MemoryRouter>
  );
  
  // Check for redirect to login page
  expect(await screen.findByText('Login')).toBeInTheDocument();
  expect(screen.getByText('Please login to access the dashboard')).toBeInTheDocument();
});
```

## Monitoring and Maintenance

### 1. Test Coverage Monitoring

- Track test coverage metrics
- Set coverage thresholds
- Identify areas with insufficient coverage

```js
// vitest.config.ts
export default defineConfig({
  test: {
    // ...
    coverage: {
      reporter: ['text', 'html', 'lcov'],
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
});
```

### 2. Test Performance Monitoring

- Monitor test execution time
- Identify slow tests
- Optimize test performance

### 3. Test Maintenance

- Regularly update tests as the codebase evolves
- Refactor tests to reduce duplication
- Remove obsolete tests

## Resources

- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [Playwright Documentation](https://playwright.dev/docs/intro)
- [Storybook Testing](https://storybook.js.org/docs/react/writing-tests/introduction)
- [GitHub Actions Documentation](https://docs.github.com/en/actions)